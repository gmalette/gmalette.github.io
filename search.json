[{"categories":["Ruby"],"content":"A few months ago, I found myself trying to explain type variance to a coworker whose experience is mainly Ruby. Dynamically typed languages such as Ruby don’t ask the developers to specify the type variance. I found that while they develop an instinct of what usages are acceptable and which aren’t, these developers don’t codify it in the same way developers in statically typed languages do. In trying to explain, I had great difficulty driving home the difference between covariance and contravariance. Their good instinct made it hard for me to fill the gap in their understanding. After a while, I remembered the way Simon Génier first explained it to me, and that way was a success.\nThis post is how I would explain type variance to a Ruby developer, without throwing the entire Computer Science manual at them. Throughout the post, we will suppose a typical Animal type hierarchy, with Dog and Cat as subtypes.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Animal def age @age end end class Cat def purr puts \"Purr\" end end class Dog def fetch(ball) puts \"Fetching the ball\" end end   Type Variance In computer programming, we can divide types into simple types (ex: Integer, String, Symbol), and types composed of other members (ex: Array, Hash, Enumerable). This composition is often called parameterization. An Array\u003cInteger\u003e (an Array of Integer) said to be parameterized by the Integer type.\nType variance allows us to describe the relationship between the composed type and its members. Intuitively, we know that Enumerable\u003cCat\u003e is a subtype of Enumerable\u003cAnimal\u003e, but it’s harder to understand that Logger\u003cAnimal\u003e is a subtype of Logger\u003cCat\u003e. I’ll explain why that’s the case, but first, let’s talk about Arrays.\nThe Curious Case of Arrays In dynamically typed languages as well as in languages that added generics after-the-fact, Arrays are weird.\nLet’s examine a print_age method takes an Array of Animals and prints their age.\n1 2 3 4  # @params animals Array\u003cAnimal\u003e def print_age(animals) animals.each { |a| puts(a.age) } end   The print_age method can be called an array containing any animal:\n1 2 3 4 5 6 7 8 9 10 11  # Array\u003cDog\u003e dog_array = [Dog.new, Dog.new] print_age(dog_array) # Array\u003cCat\u003e cat_array = [Cat.new, Cat.new] print_age(cat_array) # Array\u003cAnimal\u003e animal_array = [Dog.new, Cat.new] print_age(animal_array)   We can also have another method named adopt that adds animals to the list:\n1 2 3 4  # @params into_animals Array\u003cAnimal\u003e def adopt(into_animals) into_animals.push(Dog.new) end   Now can you adopt in the same arrays? Let’s see.\n1 2 3 4 5 6 7 8 9  # Array\u003cAnimal\u003e animal_array = [Dog.new, Cat.new] adopt(animal_array) # animal_array is still an `Array\u003cAnimal\u003e`, no problem # Array\u003cCat\u003e cat_array = [Cat.new, Cat.new] adopt(cat_array) # OH NO!!! [Cat, Cat, Dog]. This is no longer an `Array\u003cCat\u003e`   The answer is no: adopt cannot use the same arrays as print_age. However, the adopt has a property that print_age did not have, it accepts Array\u003cObject\u003e.\n1 2 3 4  # Array\u003cObject\u003e object_array = [Dog.new, Object.new] adopt(object_array) # This is fine too! [Dog, Object] is a valid `Array\u003cObject\u003e`.   We can also notice that we cannot send object_array into print_age, because Object doesn’t define the age method.\nWhat can we learn from this? Depending if you read from the array or write to it, the type doesn’t behave the same.\nSources Are Covariant Composed types from which you can exclusively read or take stuff are called sources. Examples include Enumerable and Reader. These become more specific as their type members become more specific. As a result of Dog being a subtype of Animal, Enumerable\u003cDog\u003e is a subtype of Enumerable\u003cAnimal\u003e; you can pass an Enumerable\u003cDog\u003e to any method that expects an Enumerable\u003cAnimal\u003e.\nSinks Are Contravariant Sinks are the opposite of sources: they’re types to which you can exclusively write or put stuff in. Examples include Logger or Writer. Perhaps counter-intuitively, these become more specific as their type member become less specific! That means that Logger\u003cAnimal\u003e is in fact a subtype of Logger\u003cDog\u003e (because Logger\u003cAnimal\u003e will be able to log for any Dog as well.\nRead and Write, Put and Take What if a method needs to do both? Read and write, put and take? It would appear that they are at the intersection of covariance and contravariance… and that’s exactly right: they’re invariant. No subtyping is possible.\nIn an ideal world, Array\u003cDog\u003e is neither a subtype nor a supertype of Array\u003cAnimal\u003e. In practice, even if Array, HashMap and other read/write containers should be invariant, many languages will consider them covariant because of historic reasons. Conclusion Hopefully this piece will help you understand type variance better, or explain it to a curious coworker.\n","description":"","tags":null,"title":"Type Variance Explained To a Ruby Developer","uri":"/posts/type-variance-explained-to-a-ruby-developer/"},{"categories":["Ruby"],"content":"In the first post of this series, I showed how a few APIs afford errors to their users. In the second post, I showed a few examples of how other APIs or languages have avoided or solved the same problems. In this third and final post, we will work through an example of designing an API.\nWhen I design APIs, I try to think of all the ways it could possibly be misused, and remove as many ways as possible. Sometimes, this comes at the cost of some ergonomy, but how much I’m willing to sacrifice depends on a few factors: the criticality of the errors, the impact on ergonomy, the (handwavy) likelihood that it will occur, to name a few.\nDesign Example: Reservation Manager I was recently writing an API to our reservation manager (the system holds reservation for carts, and disallows selling more items than are available). From the outside, the functionality is simple. You can reserve the items of a cart. Once reserved, the reservation can be claimed (ex: after the payment is successful) or unreserved (ex: if the payment failed).\nWho Are The Users? I think the very first step of API design is empathy. Yearn for your users to succeed in their task. Understand where they’re coming from. Make sure your APIs can be composed with the other tools they use.\nThe most important question you must ask yourself: “who will the users be?”. Are they interns, senior developers, or principal engineers? Will they use your API every day, once per quarter, or once per decade? Is your API the cornerstone of their feature, or are they using it as an afterthought?\nWhenever possible, aim for the lowest common denominator. If an intern unfamiliar with the language using this API for the first time can succeed, the probability that a principal engineer using it for the 10th time will too is very high. When it’s less practical, understanding your users will help you make the right tradeoffs between the different factors.\nIn my case, this API is likely to be used by junior developers, and very rarely. They will definitely plan ahead as this will be integral to what they’re building.\nIdiomatic API I started by jotting down a first draft of the API, that handled all the cases necessary, in an idiomatic Ruby fashion. It looked something like this:\n1 2 3 4 5 6 7 8 9 10 11  manager = ReservationManager.new is_reserved = manager.reserve(cart) if is_reserved if process_payments(cart) manager.claim(cart) else manager.unreserve(cart) end else # handle error end   However, as we’ve seen previously, this API affords a lot of errors.\nIdentifying Affordance for Errors Using the learnings from the first post, we can quickly identify a few problems:\n It’s possible to ignore the return value of reserve and treat all reservations like they succeeded. Additionally to #1, they can call claim and unreserve without having reserved in the first place. Is it legal to use different instances of ReservationManager for reserve and claim or unreserve? It’s impossible to know when the reservation has exceeded its lifetime (ex, it has been garbage collected), and it’s impossible to force the user to consume (claim or unreserve) the reservation.  For example, if the user had wrong assumptions about their system, they could write this implementation:\n1 2 3 4  manager.reserve(cart) if process_payments(cart) manager.claim(cart) end   Knowing that the users of this system will use this API approximately once in their entire career, I strongly favour reducing the surface for errors over idiomacy or ergonomy. Let’s see how we can solve this problem.\nRemoving the Affordances To partially remove the affordance #1, we need to give an incentive to the user to use the return value. In fact, we will give them no choice. We can start by making reserve return a Reservation object, which is now the owner of claim and unreserve methods. In doing so, we also solved #3; our users cannot use a different instance of ReservationManager to claim or unreserve.\n1 2 3 4 5 6 7 8 9 10  reservation = manager.reserve(cart) if reservation.success? if process_payments(cart) reservation.claim else reservation.unreserve end else # handle error end   With this API, we only partially solved #1, and we haven’t solved #2 at all, however. One can still fail to check if the reservation was successful. To solve this, we can wrap our Reservation in a Result object (aka, a kind of Either monad), forcing the user to at least check for success.\nThe usage of the Result object could be surprising to some Ruby developers, but in our codebase they are very common, and they wouldn’t startle anyone.\n1 2 3 4 5 6 7 8 9 10 11 12  result = manager.reserve(cart) result .on_success do |reservation| if process_payments(cart) reservation.claim else reservation.unreserve end end .on_error do |error| # handle error end   Using this version, the users will have no choice but to consider whether the reservation was successful before they proceed further with it.\nDepending on the various factors, we could decide to stop here; we’re already in a much better state than the original API. However for this API, I really wanted to make sure I solved #4 and force the user to claim or unreserve. We can do so by trading the return value of reserve for a mandatory block that will receive the reservation result.\n1 2 3 4 5 6 7 8 9 10 11  manager.reserve(cart) do |result| result .on_success do |reservation| if process_payments(cart) reservation.claim end end .on_error do |error| # handle error end end   This allows us to unreserve the reservation if it hasn’t been consumed by the end of the block. Depending on the specifics, we can also choose to raise if the reservation hasn’t been consumed, to notify the users that their code has a problem.\nWith this API in place, we have dramatically reduced the surface for error. The objects in play will naturally guide the our users towards the correct way to use our API, and even if they don’t, it won’t compromise the correctness of our system.\nOpinions may vary, but in mine, we haven’t sacrificed ergonomics by the slightest to get here, either.\nConclusion In the first post of this series, I showed a few ways in which common APIs allow their users to make mistakes. My goal was to help you take notice of the problem, so that you can find similar problems (and more) in your own APIs. In the second post, we saw how others have solved the same problems, to help you see ways to remove the affordance you give. In this final post, I went through an example, and explained how I design APIs, and how I try to make it easy for my users to make no error. I sincerely hope you can take something away from this series, and that you start taking notice of, and start removing, the affordance for errors in your APIs.\n","description":"In this third and final post, we work through a practical example of API design, to see how to remove the affordance for errors.","tags":null,"title":"Affordance for Errors, part 3","uri":"/posts/affordance-for-errors-pt3/"},{"categories":["Ruby"],"content":"In the first part of this series of three posts, I outlined a few common Ruby and Rails API, and explained the errors they afford their users. In this second post, I’ll discuss how other tools have avoided these problems, and how those solutions may apply to Ruby and Rails. I’ll be reusing the examples from the previous post. If you haven’t read it, I suggest you start there: Affordance for Errors, part 1.\nHow Others Have Solved Similar Problems Jump right ahead:\n ActiveRecord’s Errors API N + 1 Illegal States Ruby’s Visibility Modifiers Ignored Values Missing Coupling  ActiveRecord’s Errors API Quick reminder: Some APIs force the user to invoke methods in a particular order. Ex: ActiveRecord forces you to use the valid? method before calling the errors method (link).\n1 2 3 4 5 6 7 8 9  user = User.new user.errors.any? # =\u003e false user.valid? # =\u003e false user.errors.any? # =\u003e true   An obvious way to remove this surface for error would be to generate errors when the method is called.\nAnother, perhaps more interesting way, is Ecto’s Changeset API. It completely eliminates the problem by using Changeset which are either valid or invalid, and are the vehicle for change. If it were Rails, you would perhaps write it this way:\n1 2 3 4  changes = user.change(name: \"Guillaume\") if changes.valid? user.save(changes) end   N + 1 Quick reminder: Some APIs’s default usage mode is what users consider a mistake. Ex: ActiveRecord allows mistakenly loading records in a serial manner, rather than as a batch (link).\nI can already hear Alex Snaps complaining about ORMs. ORMs have their fair share of issues, I get it! I guess this problem exposes a conundrum: either we allow the prevalent* N+1 issue, or we force coupling between unrelated pieces of code.\nAll the approaches to solving this problem I can think of consist of considering that loading an association of a record loaded through a has_many association without specifying how, is invalid. Let’s dissect that.\n1 2 3 4 5  investor = Investor.find(id) investor.accounts.each do |account| puts account.fund.name end   In the previous code, accounts is a has_many association on investor, so any association of it cannot be loaded unless we specify how. This would prevent the account.fund from working. However, if an Account was loaded outside an association, it could still be considered valid, ex:\n1 2 3  account = Account.find(id) puts account.fund.name # this is fine   Rails already allows specifying how to load associations, with includes, eager_load, or preload, ex:\n1 2 3 4 5  investor = Investor.includes(accounts: :fund).find(id) investor.accounts.each do |account| puts account.fund.name end   This is sufficient to prevent the problem. We could also imagine a different API achieving the same results:\n1 2 3 4 5 6 7 8 9 10 11  investor = Investor.includes(accounts: :fund).find(id) investor.accounts(preload: :fund).each do |account| puts account.fund.name end # or investor.accounts.each do |account| puts account.load_fund.name end   The point is to make situations that produce N+1 only achievable explicitly. This is the path Ecto chose.\n* You don’t have to take my word for it Google “Rails performance tips and tricks”. Nearly all of them will mention N + 1 queries.\nIllegal States Quick reminder: if no illegal states can be represented, we never have to worry about the validity of our objects.\nI don’t think I can express this better than Yaron Minksy, but I’ll try to bring it into the Ruby world, if only because this is my favourite topic.\nString, Hash, and other primitives More often than not, when we use the language’s primitives, we give up an opportunity to express the domain model of our application. When we use a String to represent an Email, we haven’t encoded the fact that it needs to satisfy some constraints (ex: have an @, or satisfy a regular expression, or have a finite length). When we use Hash to represent structured data, we allow the possibility that some keys will be unset, or that some other keys will have values. We can fix all these problems by using classes specific for our use-cases.\nState Machines Finding examples for illegal states in state machines is almost trivial. A good indicator is the presence of many nullable attributes. Let’s take for example a Transaction state machine, that models the exchange of money. Without proper modelling, it could have this shape (simplified, showing only the bare minimum):\n1 2 3 4 5 6 7 8 9 10 11 12  class Transaction # The monetary value of the transaction attr_reader(:amount) # Can be `:pending`, `:success`, `:failed` attr_reader(:status) # Only present if the transaction has # failed, `nil` otherwise attr_reader(:failure_reason) # Time at which the Transaction became # `:success` or `:failed`, `nil` otherwise attr_reader(:completed_at) end   We can see in this example that some states are illegal, for example if status is :success but failure_reason is present, or if status is pending, but completed_at is present.\nWe can instead express the same object in a way that does not allow these illegal states. We can introduce classes for each possible state, that have the methods valid only for those states. The Transaction class will contain only the methods that are transcendental to states.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class TransactionPending # Nothing perticular here end class TransactionSuccess attr_reader(:completed_at) end class TransactionFailure attr_reader(:completed_at) attr_reader(:failure_reason) end class Transaction attr_reader(:money) # One of `TransactionPending`, `TransactionSuccess`, # or `TransactionFailure` attr_reader(:state) end   With this change, only valid states can be represented. It’s impossible to have a TransactionSuccess with a failure_reason, or a TransactionPending with a completed_at.\nIncomplete Booleans In Part 1, I also gave examples of “Incomplete Booleans” that can be combined to express illegal states. The example given was of two booleans: inventory_is_managed and allow_negative. The illegal states manifests itself when inventory_is_managed is false, because any value of allow_negative makes no sense. The problem is that there are 3 possible values, but the structure allows us to represent 4 values.\nWe already know many ways to express a finite-but-larger-than-two number of values. Some people will use Symbol, String, or Integer values to that effect, and validate that the value is part of a finite list.\n1 2  # can also be :managed_lax or :unmanaged product.inventory_policy = :managed_strict   The way I prefer structuring it is by using objects:\n1 2 3 4 5 6 7 8  class InventoryPolicy end MANAGED_STRICT = InventoryPolicy.new MANAGED_LAX = InventoryPolicy.new UNMANAGED = InventoryPolicy.new product.inventory_policy = MANAGED_STRICT   The first reason is that it makes type checking easier (is_a?(InventoryPolicy)). It also makes it possible to give behaviour to the different InventoryPolicy if the need arises, by adding methods to the objects. When that becomes the case, it will also be trivial to do dependency injection, for example by creating a test-only InventoryPolicy. In general, in the worst case, there is no difference between that and using symbols, and in the best case, it’s a much more extensible design.\nRuby’s Visibility Modifiers Quick Reminder: Some APIs do not meet the user’s expectations. Ex: Ruby’s visibility modifiers (private, public, protected) have no effect when using def self.method_name.\nThat this specific problem is such a common error pains me the utmost, because it is so unnecessary. Approximately 100% of other languages do not have this problem, by having visibility modifiers at the method definition level. In fact, it even works in Ruby, and many large companies have adopted this style. It may be inelegant, but it removes this opportunity for errors altogether:\n1 2 3 4 5  class Foo private def baz :baz end end   My preferred way is the method of singleton class opening, because it’s symmetric with normal class definitions:\n1 2 3 4 5 6 7  class Foo class \u003c\u003c self def baz :baz end end end   I don’t really want to dwell on this too much. The key lesson is: be empathetic towards your users, understand what they expect, and make sure your APIs match their expectations.\nIgnored Values Quick reminder: Some APIs return critical values that are easy to ignore. Ex: ActiveRecord’s save method returns false when a record could not be saved.\nIn Ruby, this affordance is very hard to remove without resorting to exceptions. For APIs where handling errors is critical, it can be enforced by requiring a lambda injection:\n1  user.save(on_error: -\u003e (e) { ... })   While I do believe that using exceptions for fatal cases is great, I personally dislike using exceptions for cases that should be handled by the user, for many reasons. I’m not sure I need to list them, and I don’t think I can do so exhaustively, but in case it’s helpful, here are a few reasons:\n Exceptions add a second way methods can return, adding complexity. Unlike in some other languages, in Ruby it’s impossible to know the entire set of exceptions a method can raise, making it very hard to know which exceptions should be expected, and of those, which should be handled. More often than not, an exception raised will leave inconsistent state in the program, in stackframes that were not equipped to deal with it.  As a result, I generally prefer returning objects that explain the error that occurred, instead of using exceptions. This makes it important to make sure the returned values are not ignored.\nSome languages have solved this problem in interesting ways; some have implemented type systems in which values of certain types cannot be produced if they are not consumed. See substructural type systems on Wiki.\nIn Rust specifically, API developers can mark return values as must_use, meaning that the return value must be consumed (or checked). Failing to do so would result in a compiler warning. ATS achieves similar results via a concept of “proofs” where unconsumed proofs prevent compilation.\nIn languages where destructors are controlled, it would be possible to panic if the return value has not been consumed.\nIn Ruby, you could technically do it by using define_finalizer(obj) { raise } and undefine_finalizer(obj) :trollface:.\nMissing Coupling Quick reminder: Some APIs require things that go together, without expressing the coupling. Ex: Hash requires the methods hash and eql? to be coupled, without expressing it. Moreover, the Object class defines both methods, making it easy to define one without defining the other, leading to subtle bugs.\nThe ergonomics around this are hard to get right. One possibility would be to remove hash and eql? from all objects. This would be a large inconvenience, and I don’t think the added correctness would be worth it. Another would be to force reimplementing one method if the other is redefined. I think this second approach would be viable; we wouldn’t sacrifice much ergonomics, yet we’d largely prevent this type of error.\nThis, of course, is where interfaces (or traits) shine, by expliciting the coupling between all the required pieces an API needs.\nConclusion In this post, we covered the various affordances given by common Ruby and Rails APIs, as well as common mistakes I’ve seen in codebases I worked on. We explored ways to spot them and avoid making them in designing our own APIs. I hope you learned something, or that this post helped you put words on ideas you already had, such that you can discuss them with the people on your teams, such that we can all build better APIs, with less affordance for errors. In Part 3, I will be going over how I approached and designed a specific API.\n","description":"In this second post of three, I show how other APIs and languages have avoided some of the problems shown in the first post.","tags":null,"title":"Affordance for Errors, part 2","uri":"/posts/affordance-for-errors-pt2/"},{"categories":["Ruby"],"content":"A few years ago, I read Sandi Metz’s blog post about affordances and it stuck with me. I started minding how the APIs I write can be misused; I started noticing the surface I leave for the users of my APIs to make errors. Soon after I started noticing how the APIs we use every day are full of affordance for error.\nIn this first of three posts, I want to show a few examples of how common APIs (mostly in Ruby and Rails) can be accidentally misused. Maybe this will spark a discussion, or will incite people to share other issues they’ve seen. The second post will explore solutions to the problems from this post. In the final post of this series, I will show how I approach API design to minimize the affordance for errors while offering the best ergonomics I can.\nWhy Bother? You may be wondering why this matters, why can’t just write better code, without mistake. After all, we’re smart people, we should be able to learn these tools and to not make mistakes… If you are the kind of developer that can write bug-free code, this blog post is even more so for you, as your coworkers cannot. Developers are humans. We get tired, we forget, our attention lapses, we’re juggling umpteen other things in our heads. For many reasons, we end up making mistakes. It is then our shared responsibility to make your APIs human-friendly.\nMoreover, good APIs minimize the amount of mistakes we can make, they remove the pain and frustration of using them. They lower the cost of entry. They don’t require you to understand how things are implemented “on the metal”. Providing good APIs with minimal affordance for errors is about making the life of your fellow developers just a little better, making them just a little more productive, easing their cognitive load just a little.\nGood APIs will naturally guide developers towards the best ways to use them, in the same subtle yet important way the bumps on the F and J keys guide your hands towards the good hand placement.\nMy hope is that after reading this post, you too will start taking notice of what errors you afford your users, and that we can all use this as a starting point to write better, human-friendlier APIs.\nExamples of Surfaces for Errors Jump right ahead:\n ActiveRecord’s Errors API N + 1 Illegal States Ruby’s Visibility Modifiers Ignored Values Missing Coupling Extending Self super vs super()  ActiveRecord’s Errors API I want to start this off with an easy, approachable example: ActiveRecord’s errors API, which requires a specific incantation.\n1 2 3 4 5 6 7 8 9 10 11 12 13  class User \u003c ApplicationRecord validates(:name, presence: true) # 1 end user = User.new # 2 user.errors.any? # 3 # =\u003e false user.valid? # 4 # =\u003e false user.errors.any? # 5 # =\u003e true   For those unfamiliar with Rails, in the previous example, we\n We create a User class which specifies that the name attribute must be set, otherwise it’s not valid (#1) We then instantiate a User, without giving it a name (#2); we can then expect it to be invalid However, we can see that it contains no errors (#3) This is because ActiveRecord requires the programmer to use valid? (#4) before calling errors, which mutates the User to set errors (#5)  APIs like this can often be exposed in ways that completely suppress the problems, so much so that I’ve always been stricken that Rails kept choosing not to do anything (reminder: exploring solutions will be the topic of the second post).\nN + 1 Some APIs, like ActiveRecord, allow mistakenly loading data serially instead of in a batch manner, without guiding the user towards the more performant approach.\n1 2 3 4 5 6 7 8 9  investor = Investor.first investor.accounts.each do |account| puts account.fund.name end # Fund Load (1.2ms) SELECT \"funds\".* FROM \"funds\" WHERE \"funds\".\"id\" = $1 LIMIT $2 [[\"id\", 6], [\"LIMIT\", 1]] # Fund Load (1.4ms) SELECT \"funds\".* FROM \"funds\" WHERE \"funds\".\"id\" = $1 LIMIT $2 [[\"id\", 7], [\"LIMIT\", 1]] # ... and so on for each account   Because the code that loaded the investor object did not preload the fund, every iteration of the loop will issue a query to load one fund.\nIf you have used Rails with ActiveRecord for more than a few days, the probability that you’ve encountered or written code with this mistake are high. This problem is so common that a gem (Bullet) was written to help developers detect when they cause it.\nIllegal States If I were to choose, this would be the most important one.\n Make illegal states unrepresentable\n Attributed to a 2011 post by Yaron Minksy (which I became aware of only much later), this quote completely changed the way I approach software design. This practice eliminates so many possible mistakes that it’s hard to even explain the implications.\nIf no illegal state can be represented, we never have to worry about the validity of objects.\nMore often than not, however, we write code that allows representing invalid state. ActiveRecord initialization is a good example, but there are so many others. All APIs that use Hashes to represent state immediately allow illegal state. There are many, many variations of APIs offering this kind of surface for errors, I encourage you to keep your eyes peeled and take notice.\nIncomplete Booleans One example, I’ve recently used an APIs for inventory management using a number of booleans to represent possible states, but the number of allowed states is less than the booleans combined values allow. Inventory items can be configured with the boolean values inventory_is_managed (the inventory counter can be set and is decremented after a sale), and allow_negative (the item can continue selling once after it the counter reached zero).\nThe problem is that this API has 4 configurations, but only 3 are valid:\n (inventory_is_managed: true, allow_negative: true) the inventory is managed, but can go negative (inventory_is_managed: true, allow_negative: false) the inventory is managed, and cannot go below zero (inventory_is_managed: false, allow_negative: _) the inventory is not managed; whether or not it can go below zero is meaningless  Users of this API should not be able to set any value for allow_negative if inventory_is_managed is false.\nEmail is a String, Struct is a Hash Ruby code is plagued with primitive obsessions. We represent emails using String, and “complex” data using Hash. Neither of these classes allow preserving the invariants of our system (ex: the email matches a regular expression). As a result, most codebases I’ve seen build defenses; they validate the state more than once.\nRuby’s Visibility Modifiers There’s an entire category of errors stemming from APIs allowing you to do the wrong thing, while seemingly doing the right thing.\nVisibility modifiers (private, protected, public) are prime examples; they are the source of many mistakes, by newcomers’s mismatched expectations and veterans’s lapse of attention. To say nothing of the fact that protected means something different than in other languages, many devs make mistakes when it comes to singleton methods, often called “class methods”. Here’s an example:\n1 2 3 4 5 6 7  class Foo private def self.bar :bar end end   Many devs would expect the Foo.bar method to be private to Foo–perhaps because many call it a class method–, however it is not. The reason is that private is a method on Foo, telling it to mark the methods defined after as private. It does not affect Foo's singleton class. To learn more about the relation between classes and their singleton classes, refer to The Ruby Object Model.\nThat it is such a common error pains me the utmost, because it is so unnecessary. Approximately 100% of other languages do not have this problem, by having visibility modifiers at the method definition level. In fact, it even works in Ruby, but I digress.\nIgnored Values Some APIs will use values that are easy to ignore, once again leading to errors.\nWhile I don’t want to seem like I pick on ActiveRecord, it contains examples within reach.\n1 2 3 4 5 6  def update user.update(user_update_params) user.save respond_with(user) end   In this example, the return value of user.save–a Boolean indicating whether the persistance was successful or not–is not checked. The error case, when save fails, is not handled. ActiveRecord doesn’t help nor guide towards handling it, either.\nIf you think your code is impervious to this problem, I suggest you look at your test suite. If you’re using save and not save! to setup objects, and unless you have very high code hygiene, chances that at least one started failing since you wrote it.\nMissing Coupling APIs sometimes need things to be coupled, but don’t express it. For example, in Ruby, any object can be a Hash key by defining two methods: hash and eql?. However, this is not encoded at runtime. To make things worse, the Object class defines an implementation based on object equality.\nAs a result, it’s easy for developers to redefine either of the two methods but not both. This can easily lead to situations where the objects seem to be valid hash keys, until there two items end up in the same bucket, or, conversely, when two items should fold together, but don’t.\nExtending Self The usage of extend(self) in module is probably one of my biggest pet peeves. It’s used to add methods to the singleton class of a module, effectively allowing the module to receive the methods it defines. Ex:\n1 2 3 4 5 6 7 8 9 10  module Foo extend(self) def foo # 1 :foo end end Foo.foo # 2 # =\u003e :foo   In the previous example, the module Foo defines the method foo (#1) which is available on Foo (#2) due to the extend(Foo). Not only does this idiom produce a complicated object, the fact that it’s an idiom affords users some errors.\nI think people fail to consider the implications of these modules. Should Foo be used as a singleton, or should it be include'd, as modules are? In the previous example, it doesn’t matter. When you start using instance variables and state, it does.\nsuper vs super() In Ruby, as we know, parentheses are optional, unless they aren’t. The usage of super is such an example, where super (without parentheses) is semantically different to super() (with parentheses).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class Parent end class WithParentheses \u003c Parent def initialize(var) @var = var super() end end class WithoutParentheses \u003c Parent def initialize(var) @var = var super end end WithParentheses.new(1) # 1 # =\u003e #\u003cWithParentheses:0x000...\u003e WithoutParentheses.new(1) # 2 # =\u003e ArgumentError: wrong number of arguments (given 1, expected 0)   This example shows the semantic difference between both versions.\nThe reason is that super (without parentheses) sends the arguments verbatim, whereas super() (with parentheses) sends no argument.\nConclusion I hope this post has opened your eyes on the amount of affordance for errors offered by our languages and APIs. I hope you’ll start noticing them in the code you’re writing, and you’ll strive to remove as many as possible.\nPost Scriptum My list contained many other affordances that didn’t make the cut for this post. To name a few:\n HashWithIndifferentAccess blurring the line between String and Symbol validates_uniqueness_of is racy by default assert(obj, message) is easily mistaken with assert_equal(a, b) config(default_value: :false) (using a symbol where a boolean was expected) ActiveRecord scopes behaving like Array but not quite Using of structureless markup languages (YAML)  If you wish to contribute with more examples, please share them in the comments.\n","description":"In this first posts of three, I highlight a few examples of affordance for errors in common APIs.","tags":null,"title":"Affordance for Errors, part 1","uri":"/posts/affordance-for-errors-pt1/"},{"categories":["Ruby"],"content":"Following my Short Rant on ActiveSupport::Concern, I’ve been asked how to refactor the code to make it stop using it, or write new code without it. I thought I’d share the patterns that have worked for me so far.\nWhat is ActiveSupport::Concern? ActiveSupport::Concern is a module which other modules can extend to get its features. It allows for easily (note: easy, not simple) applying modifications to the receiver module and its singleton class, as well as triggering hooks when the module gets include'd.\nThe following code contains all the marks which identify ActiveSupport::Concern (later AS::C):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  module Concern extend(ActiveSupport::Concern) included do # 1 puts(\"Hello from #{self}\") end module ClassMethods # 2 def baz end end class_methods do # 3 def bar end end end module ReceiverModule include(Concern) # 4 end   The previous code uses all the AS::C features, which are (annotated in the code):\n Setting up a callback, for when the module is included (4). The callback is class_eval'd on the receiver module, in our case ReceiverModule. Open (or reopen) the ClassMethods module. When Concern is included in ReceiverModule, AS::C will also do ReceiverModule.extend(Concern::ClassMethods). Same as 2, different style. ReceiverModule uses our Concern module. The result is that ReceiverModule's singleton class will have both baz and bar, and the code will print \"Hello from ReceiverModule\".  Another pattern you may see is the following:\n1 2 3 4 5 6 7  module AnotherConcern include(Concern) extend(ActiveSupport::Concern) def toto end end   While AnotherConcern appears to not use any of AS::C's features, it’s “reexporting” the hooks from Concern. This is why I often say that metaprogramming breeds metaprogramming: Concern's use of metaprogramming forced AnotherConcern to also use metaprogramming, otherwise it would not be able to offer Concern's functionality.\nNow that we’ve identified the telling signs of AS::C (included callback, ClassMethods module, and class_methods block), we can go about refactoring away from it!\nUseless Extend Believe it or not, extending AS::C for no reason nor benefit is extremely common. It also has a nice property of being trivial to remove. You’ll be able to tell that it’s uselessly extended when the receiver module has none of its telling signs, and does not include any other modules which use AS::C.\nIf the module has none of these, it’s safe to remove ActiveSupport::Concern, given this code:\n1 2 3 4 5 6  module ConcernModule extend(ActiveSupport::Concern) def my_method end end   You can apply these changes:\n1 2 3 4 5 6  module ConcernModule - extend(ActiveSupport::Concern)  def my_method end end   ClassMethods only, please Modules that use ActiveSupport::Concern with the only benefit of having the receiver subsequently extend the module’s ClassMethods. You’ll notice this pattern when the only interesting piece of code in the module is the ClassMethods module. I suspect this happens when folks find it hard to understand the difference between include and extend–which is admittedly quite hard to make–, leading them to cargo-paste this code from elsewhere.\nSidenote: to learn more about include and extend, I suggest reading my previous blog post: [The Ruby Object Model]({% post_url 2019-02-01-the-ruby-object-model %}).\nThe code you’d be looking at would look something like this:\n1 2 3 4 5 6 7 8 9 10 11 12  module ConcernModule extend(ActiveSupport::Concern) module ClassMethods def a_class_method end end end module ReceiverModule include(ConcernModule) end   The good news is that this is also trivial to fix. You can remove the ClassMethods module and move its behaviour to ConcernModule. Then replace include(ConcernModule) with extend(ConcernModule), so that the behaviour is applied on the receiver’s singleton class instead of the receiver itself.\n1 2 3 4  module ConcernModule def a_class_method end end   1 2 3 4  module ReceiverModule - include(ConcernModule) + extend(ConcernModule) end   Another variant of this is to use a class_methods block instead of the ClassMethods module. The same refactor applies.\nCallback Methods Sometimes, AS::C is used for its included callback only. Sometimes, it will coincide that the block behaviour can be implemented in another, simpler way.\n1 2 3 4 5 6 7 8 9  module TestHelper extend(ActiveSupport::Concern) included do teardown do clean_up_after_tests end end end   This previous example uses the included callback to call the teardown method in Minitest. Instead of this, we can define a teardown method.\n1 2 3 4 5 6  module TestHelper def teardown clean_up_after_tests super end end   This will unfortunately only work if the hooks can also be implemented using methods.\nMetaprogramming the Metaprogramming Another variation of the previous pattern is defining the methods in the hooks, for no clear reasons. This means that every time ModuleDefiningMethods is included, it will define new versions of the foo and bar methods. Every time I’ve seen this, it was unwanted.\n1 2 3 4 5 6 7 8 9 10 11  module ModuleDefiningMethods extend(ActiveSupport::Concern) included do def foo end def bar end end end   In this case, we can simply remove the included block but keep the contents. The modules which include ModuleDefiningMethods don’t even have to change.\n1 2 3 4 5 6 7  module ModuleDefiningMethods def foo end def bar end end   Now that we’ve gotten our hands dirty refactoring the easy cases, let’s see what we can do about the more involved ones.\nCoupling Class and Instances I’ve often seen this kind of offense, where one tries to add behaviour to the instances of a class, and other behaviour (often configuration) to the class itself. Example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  module ParameterFiltering extend(ActiveSupport::Concern) included do class_attribute(:allowed_params) # 1 end def filtered_params # 2 ParameterFilter.new(self.class.allowed_params).filter(params) end module ClassMethods def allow_params(*param_names) # 3 self.allowed_params = param_names end end end class FooController include(ParameterFiltering) allow_params(:foo, :bar, :baz) def create Foo.create(filter_params) end end   What this code does:\n Sets up a class attribute named allowed_params. Defines an instance method to return the filtered params, based on which are allowed. Defines a class-level method to set the allowed_params attribute in an “idiomatic macro”.  This code unnecessarily couples the class (FooController) with its instances. Additionally, the overuse of metaprogramming in this code makes it harder to change, say, how parameters are actually filtered.\nAn easy change we can make to keep the code as convenient while reducing the complexity is to move allowed_params from a “macro” to a method. The resulting code will be slightly less idiomatic, but much simpler. I think that’s a good thing.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  module ParameterFiltering def filtered_params ParameterFilter.new(allowed_params).filter(params) end def allowed_params raise NotImplementedError # Signal to your users that they must implement this method end end class FooController include(ParameterFiltering) def create Foo.create(filter_params) end private def allowed_params [:foo, :bar, :baz] end end   Another option we have would be to make the allowed_params an argument to the filter_params method. This would increase the convenience, as callsites can filter on different arguments.\nFinally, yet another refactor would be to get rid of the ParameterFiltering module entirely. Instead, we can instantiate a ParameterFilter, bind it to a constant, and reuse the same instance of ParameterFilter for all instances of the controller (provided it doesn’t have mutable state). Object Oriented Programming has taught us favour composition over inheritance, and this approach subscribes to that philosophy.\n1 2 3 4 5 6 7  class FooController ParamFilter = ParameterFilter.new([:foo, :bar, :baz]) def create Foo.create(ParamFilter.filter(params)) end end   Unfortunately, this option is too often overlooked, even though it has powerful arguments in its favour. In our case, since the instance of ParameterFilter can be reused, we’ll be allocating less objects. The resulting code is also both simpler and easier to understand. Finally, we’ll easily be able to compose objects to obtain the behaviour we want, a task which would be much harder if we used any of the previous patterns. Ex:\n1 2 3 4 5 6 7 8  class FooController ParamFilter = RejectLongParameterValues.new(ParameterFilter.new([:foo, :bar, :baz]), max_length: 30) def create Foo.create(ParamFilter.filter(params)) end end   Class Macro, Instance Functions This is a slight variation on the “Coupling Class and Instances” pattern, except that the main behaviour of the module is adding a “macro” to define instance methods. This pattern tends to happen when the defined method becomes long, and developers want to extract parts of it into functions. Having nowhere obvious to put the extracted methods, we resort to also using instance methods (it’s the easiest).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  module ValidatedAttribute extend(ActiveSupport::Concern) module ClassMethods # The `attribute` method is a \"macro\". The `valid?` method has been extracted from it. def attribute(name) define_method(name) do # work valid_attribute?(thing) # work some more end end end def valid_attribute?(attribute) # work end end   Refactoring this is quite easy in most cases: we can make them functions. This will allow us to get rid of the ClassMethods module. It also has nice benefits: the valid_attribute? function becomes much easier to test, we don’t risk clobbering other methods with the same name, and the instances have one less level of inheritance.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  module ValidatedAttribute # The `attribute` method is a \"macro\". The `valid?` method has been extracted from it. def attribute(name) define_method(name) do # work ValidatedAttribute.valid_attribute?(thing) # work some more end end class \u003c\u003c self def valid_attribute?(attribute) # work end end end   A Pattern I Don’t Know How To Refactor There are still a few usage patterns of AS::C which I don’t know how to easily refactor, they would require fundamental changes. These have always been around adding another layer metaprogramming, often under the guise of convenience. Here’s an example, involving metaprogramming and ActiveRecord. The CanBeActive module adds a scope to the class, and a method to the instances. While I don’t consider this to be good practice, I don’t see a more convenient way to achieve the same results.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  module CanBeActive extend(ActiveSupport::Concern) included do scope(:active, -\u003e { where(active: true) }) end def inactive? !!active? end end class User \u003c ActiveRecord::Base include(CanBeActive) end   I personally don’t worry too much about the byte size of the codebase, and I would probably skip the module in this case, and implement the same logic in all classes which use it, unless that is, the CanBeActive is actually a concept my application uses, ex: if I had a ActivationController which accepts any CanBeActive resource. That is, I would add this module not as a way to share code, but as a way to identify a common concept.\nConclusion Hopefully this post has proven that removing occurrences of ActiveSupport::Concern is generally easy, if not trivial. Often it can be removed without further changes. Other times, it just requires understanding the difference between include and extend, or knowing if methods can be used instead of “macros”. Sometimes it’s about getting to a better OOP design, but mostly, it’s about combining objects rathern than piling more layers of metaprogramming.\nAnd sometimes, you just have to give up and add another layer of metaprogramming, in which case feel free to use AS::C.\nComment or React\n","description":"Following my Rant on ActiveSupport::Concern, I’ve been asked how to refactor the code to make it stop using it, or write new code without it. I thought I’d share the patterns that have worked for me so far.","tags":null,"title":"Refactoring Common ActiveSupport::Concern Patterns","uri":"/posts/refactoring-common-activesupport-concern-patterns/"},{"categories":["General"],"content":"When I started writing, I picked Medium. I didn’t want to setup a blog, have choose a template or style, or figure out how to use an analytics platform. I just wanted to write.\nWhen writing my Revoking the (Parentheses) Privilege post, it became apparent that Medium failed me. It has no support for syntax highlighting, requiring me to use screenshots from Carbon. I’m considering a post which will require JS to create visualizations, and it would be impossible on Medium.\nI’ve since switched to using Jekyll and Github Pages. I like that all revisions of my posts will be available to everyone. I like that it’s a property I (almost) control: I’ll soon switch to my own domain name.\nFrom Medium I miss the editor (although coming back to Vim feels nice), and most definitely the easy analytics. I’ll try to use Google Analytics, but I’m somewhat apprehensive of how that’ll go. I’ll miss the “Claps”. For this I’ll ask readers to react on the GitHub; I’ll create a pull request for each new post. Comments can live there too. I’ll miss the subscriptions, but for this I’ll use releases on the repository.\nHoping this’ll stick!\nComment or React\n","description":"","tags":null,"title":"Moving Away from Medium","uri":"/posts/moving-away-from-medium/"},{"categories":["Ruby"],"content":"Recently I was called out. I hypothesized that some bad patterns in Ruby are caused by developers misunderstanding Ruby’s Object Model, but I had not provided them with any learning resources. In fact, I couldn’t find anything satisfying, so I decided to write this post.\nEdit: I’ve been sent other resources about Ruby’s Object Model:\n All I’d Wanted to Know about Ruby’s Object Model Starting Out…and Mooar!!! in which Jun Qi Tan explains what I tried to in this post, in a much more eloquent talk. Unraveling Classes, Instances and Metaclasses in Ruby by Jeff Kreeftmeijer in the excellent Ruby Magic series. Metaprogramming in Ruby by Paolo Perrotta has a section on the object model.   This post is aimed at developers familiar with Ruby and Object Oriented Programming. I’ll assume you have some understanding of what objects and classes are, and that you can read Ruby code without commentary. If you want to learn more about Ruby, or if this post has you itching for more, I must recommend Ruby Under The Microscope by Pat Shaughnessy. Chapter 5 goes in-depth in the data structures the Ruby VM (MRI) uses for objects and classes.\nIf you’d rather skip the wall of text, visit the TL; DR. Otherwise, let’s get started!\nObjects You’ll hear it often: all values in Ruby are objects, and all expressions return values. It is thus commonly said that “Everything in Ruby is an Object”. Let’s add some objects to our program. We’ll use the this code for the entire section:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  class Animal def initialize @affection = 0 end def pet @affection += 1 end end class Cat \u003c Animal def initialize(name) @name = name super() end def pet puts(\"purrr\") super end end coco = Cat.new(\"coco\") coco.pet # =\u003e prints \"purrr\"   Objects in Ruby are just a combination of state—the values of instance variables—, with a class attached to it. The class of an object defines the methods the object has access to. Ruby is easily introspectable, so we can ask it about the state and class of coco.\n1 2 3 4 5 6 7  # State coco.instance_variables # =\u003e [:@name, :@affection] # Class coco.class # =\u003e Cat   coco's state contains two instance variables: @name and @affection. Its class is Cat. Nothing surprising so far.\nThe word “class” in Ruby can mean multiple things: the instantiatable class which provides behaviour to its instances, the class object, or both. When talking about an object’s class, we generally intend to describe the methods defined by that class. For this purpose, we will use the word behaviour from now on.\nClasses In the Objects section we learned that classes have multiple facets, and one of them is providing the behaviour of instances of that class. This is done by setting up an ancestor chain (also called “inheritance chain”). They can be inspected at runtime using the ancestors method. This allows us to clearly see that coco contains the behaviours defined by Cat, Animal, Object, and so on.\n1 2  coco.class.ancestors # =\u003e [Cat, Animal, Object, Kernel, BasicObject]   The ancestor chain is a linked list. For Cat, it looks like this:\nWhenever you call the pet method on coco, the Ruby VM will find the behaviour in coco's class’s ancestor chain (Cat's, that is), from left to right: starting with Cat, then Animal, and so on, until the method is found. When calling super within that method, Ruby would find the next ancestor defining a behaviour for the pet method, and invoke it, in this case, the one defined in Animal.\nIn the previous figure, ancestors after Animal (Kernel and BasicObject) have been omitted.\nTo know which methods are defined on each ancestor in the ancestor chain, use the instance_methods method. The boolean argument specifies whether to also include the methods defined by the class’s other ancestors.\n1 2  Cat.instance_methods(false) # =\u003e [:pet]   In Ruby, classes are also values, which means they are also objects. This is interesting; it means that in addition to defining methods, classes are also the combination of state and a reference to a class.\nFor this facet (objects which are instances of the Class class), we will be talking about class objects.\nClass objects have a method named new, which comes from the behaviour defined by the Class class.\n1 2  Cat.method(:new).owner # =\u003e Class   The default behaviour of the new method is to return a new object: it instantiates the class.\n1 2 3  coco = Cat.new(\"coco\") coco.class # =\u003e Cat   While this method can be changed by any class in the ancestor chain, this privilege is rarely abused and is frowned upon, but know that one could do it.\nFor some, it may be surprising that the Class class is a subclass of the Module class, meaning that all class objects are also Modules. In the next section, we will talk about modules; remember that many things will also apply to class objects.\n1 2  Cat.class.ancestors # =\u003e [..., Module, ...]   Modules 1 2 3 4 5  module Quadruped def feet_count 4 end end   Modules, like classes, have two facets: they are values (thus, objects), and they can define behaviour for other objects. Unlike class objects however, Module objects do not have a method named new, and cannot be instantiated directly.\n1 2 3 4  Quadruped.new # Traceback (most recent call last): # 1: from (irb) # NameError (undefined method `new' for class `Module')   Since Modules cannot be instantiated nor subclassed, they need another way to be used as an object’s behaviour. This is done by using the include, prepend, and extend methods on Module objects (and on class objects!). I’ll describe include and prepend now, but keep extend for later.\nInclude When using include(A), the module (A) is inserted in the ancestor chain of the receiver module. Its methods are thus made available on instances of the receiver.\n1 2 3 4 5  class Cat \u003c Animal include(Quadruped) end # Or the equivalent: `Cat.include(Quadruped)`   The previous code will add Quadruped as an ancestor to Cat, making its methods available to all instances of Cat.\n1 2 3 4 5  coco.class.ancestors # =\u003e [Cat, Quadruped, ...] \u003e coco.feet_count # =\u003e 4   Note that include adds the module to the ancestor chain after the receiver; Quadruped appears after Cat.\nIn the Objects section, we said that the ancestor chain’s order is used to determine which method gets called first. Using another example, we can confirm this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  module A def foo puts(\"in a\") end end class B include(A) def foo puts(\"in b\") super end end B.new.foo # prints: # in b # in a   Some people are surprised that this behaviour remains unchanged if we move include(A) to after the method definition. The important thing to remember is that an object’s behaviour is defined by its class’s ancestor chain; moving include(A) lower down has no impact on the ancestor chain.\nPrepend Prepend is very similar to include with one very important distinction: it adds the module before the receiver.\n1 2 3 4 5 6  class Dog prepend(Quadruped) end Dog.ancestors # =\u003e [Quadruped, Dog, ...]   This means that behaviours defined by Quadruped will have precedence over those defined by Dog. The following figure shows the distinction: prepend adds the module to the beginning of the ancestor chain, while include adds it right after the receiving module.\nSingleton Classes 1 2 3 4 5 6 7 8  dora = Cat.new(\"dora\") # Dora has mitten paws def dora.number_of_toes 22 end dora.number_of_toes # =\u003e 22   Earlier in this post, I said that objects are the combination of state and a class. This is slightly less than accurate. In fact, two objects instantiated from the same class, are not necessarily of the same type. This is (you probably guessed it from the section title) because of the singleton class. The truth is, every object in Ruby possesses its very own class, of which it is a singleton. You may also have seen “eigenclass”—another word for singleton class—, or “metaclass”, which is specifically a Class object’s singleton class. In our code, dora and coco don’t have the same class, which explains why coco does not have the number_of_toes method:\n1 2 3 4  coco.number_of_toes # Traceback (most recent call last): # 1: from (irb) # NoMethodError (undefined method `number_of_toes' for #\u003cCat:0x00007fe5201b0f78 @name=\"coco\"\u003e)   As such, the “true” class of an object is its singleton class.\n1 2 3 4  dora.singleton_class.instance_methods(false) # =\u003e [:number_of_toes] dora.singleton_class.ancestors # =\u003e [#\u003cClass:#\u003cCat:0x00007fe52016e3a8\u003e\u003e, Cat, Quadruped, ...]   The weird #\u003cClass:#\u003cCat...\u003e\u003e up there means “the singleton class of the Cat object 0x00007fe52016e3a8”, which is dora:\n1 2  dora # =\u003e #\u003cCat:0x00007fe52016e3a8 @name=\"dora\"\u003e # notice the `0x00007fe52016e3a8`   The following diagram shows the hierarchy of both coco and dora, with their respective singleton classes; only dora's singleton class defines the number_of_toes method.\nAstute readers will correctly understand that, in many cases, an object’s singleton class can be elided (omitted) by the virtual machine. In fact, if the VM did not elide most of them, no Ruby program would be able to run. This is because class objects also have singleton classes, and Singleton classes are also class objects, which themselves also have singleton classes… and so on recursively. In our previous example, coco's singleton class can be elided since it neither defines methods, nor has state.\nMethods defined on a class object’s singleton class are sometimes erroneously called “static functions”. This nomenclature is misleading; we should avoid it. Using it sets us up for expectations the Ruby VM cannot meet. The reason is, they are not functions, they are nothing more than methods defined on a class object’s singleton class. Additionally, constants in Ruby are not truly constant, so these methods are not static either.\nThere are several ways to define methods on a class’s singleton class.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  def Cat.feline? # Like the `number_of_toes` example true end class Cat \u003c Animal def self.feline? # `self` is `Cat` here, so this is exactly the same as the previous example true end end class Cat \u003c Animal class \u003c\u003c self def feline? true end end end   In this last example, class \u003c\u003c self is a special syntax which opens self's singleton class, in this case, Cat's, similar to how class Cat opens the Cat class. Everything that can be done in Cat to affect its instances can be done within class \u003c\u003c self to affect the only instance of Cat's singleton class, which is Cat itself. (oh god, I’m going to lose people over this overuse of the words “class” and “singleton”, aren’t I?)\nOf these 3 forms however, there is a clear “better way” in terms of simplicity and predictability: class \u003c\u003c self. Other means will fail the programmer’s expectations more often than not, e.g. around method visibility:\n1 2 3 4 5 6 7  class Cat \u003c Animal private def self.are_the_best? true end end   One would expect the are_the_best? method defined by Cat's singleton class to be private, but it is not.\n1 2  Cat.are_the_best? # =\u003e true   I didn’t intend to talk about method visibility in this object model post, but let’s just briefly go there, to show an example of Ruby failing to meet expectations. The reason for this unexpected behaviour is that private is not a keyword, it is a method. In this case, it will be received by Cat, allowing it to make any new method defined on it as private. Cat's singleton class however, does not receive this method call to private. As a result, it is not aware that it should change the visibility of methods that will be defined.\nHad we used the class \u003c\u003c self syntax instead, it would have worked as expected:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Cat \u003c Animal class \u003c\u003c self private def are_the_best? true end end end Cat.are_the_best? # Traceback (most recent call last): # 1: from (irb) # NoMethodError (private method `are_the_best?' called for Cat:Class)    So far, we’ve seen Objects, Classes, Modules, and Singleton Classes. This is a great time to take a break! In the next section, we’ll see extend, and singleton class inheritance.\n Extend The extend method confuses many people: how is it different from include and prepend? When should they use one, or the other? To answer that question, consider the following code:\n1 2 3 4 5 6 7 8 9 10 11 12 13  module D def a \"Hello? This is D\" end end class E include(D) end class F extend(D) end   Can we predict what behaviour we can expect from E and F? If we recall from the previous sections, an object’s behaviour is provided by its class’s ancestor chain. Let’s try it:\n1 2 3 4  E.ancestors # =\u003e [E, D, Object, ...] F.ancestors # =\u003e [F, Object, ...]   That’s interesting! We can expect instances of E to have D's behaviour, but not instances of F.\n1 2  E.new.a # =\u003e \"Hello? This is D\"   So far so good, E does indeed have D's behavour.\n1 2 3 4  F.new.a # Traceback (most recent call last): # 1: from (irb) # NoMethodError (undefined method `a' for #\u003cF:0x00007febf409e218\u003e)   Success! We correctly predicted this too. If instances of F don’t have D's behaviour, could the class object F have it then? To predict it, we can ask F's singleton class!\n1 2  F.singleton_class.ancestors # =\u003e [#\u003cClass:F\u003e, D, #\u003cClass:Object\u003e, ...]   It does have D!\n1 2  F.a # =\u003e \"Hello? This is D\"   What does this tell us? It looks like extend applies to the singleton class’s the same changes which include does to the class’s. If that were the case, it means we could achieve the same results by calling include within the singleton class instead.\n1 2 3 4 5 6 7 8 9 10 11  class D class \u003c\u003c self include(D) end end D.singleton_class.ancestors # =\u003e [#\u003cClass:D\u003e, D, #\u003cClass:Object\u003e, ...] D.a # =\u003e \"Hello? This is D\"   It works as predicted!\nI should note that this is not exactly true, extend and singleton_class.include are slightly different. Whenever a module gets added to the ancestor chain of another module, the first module gets a callback on one of three methods: prepended, included, extended. Some side-effects could be expected from these methods, and you may be required to use a specific method to get these side-effects.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  module Mod def self.included(receiver) puts \"Mod is included by #{receiver}\" end def self.prepended(receiver) puts \"Mod is prepended by #{receiver}\" end def self.extended(receiver) puts \"Mod is extended by #{receiver}\" end end module G include(Mod) end module H prepend(Mod) end module I extend(Mod) end # prints: # Mod is included by G # Mod is prepended by H # Mod is extended by I   Extend on All Objects Did you know that most objects have the same extend method? Now that we know that extend modifies the behaviour of the receiver (by adding the argument to the receiver’s singleton class’s ancestor chain), we can predict what happens if we use extend directly on any object*.\n1 2 3 4 5 6 7 8 9 10 11 12 13  module OwnedByGuillaume def owner \"Guillaume\" end end coco.extend(OwnedByGuillaume) coco.singleton_class.ancestors # =\u003e [..., OwnedByGuillaume, ...] coco.owner # =\u003e \"Guillaume\"   As predicted, the receiver (coco) has the behaviour offered by OwnedByGuillaume.\n*although calling extend on any object is perfectly valid Ruby, I urge you to either not use it, or use it very parsimoniously\nSingleton Class Inheritance In Ruby, singleton classes are subclasses of their instance’s original class. Heh, this is a bit hard to follow, let’s do an example.\n1 2  coco.singleton_class.superclass # =\u003e Cat   In the previous code, we can see that coco's singleton class is a subclass of Cat, like Cat is a subclass of Animal. For class objects, their singleton class are subclasses of their superclass’s singleton class: Cat's singleton class is a subclass of Animal's singleton class, which is itself a sublcass of Object's singleton class, and so on.\n1 2  Cat.singleton_class.ancestors # =\u003e [#\u003cClass:Cat\u003e, #\u003cClass:Animal\u003e, #\u003cClass:Object\u003e, ...]   The next figure illustrates the relationships between class objects, their singleton classes, and their respective superclasses.\nModules, however, are not inherited at both levels (class and singleton class behaviours). Instead, the programmer picks which ancestor chain will be impacted by using either prepend or include (class), or extend (singleton class).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  module Included end module Extended end class L include(Included) extend(Extended) end class M \u003c L end M.ancestors # =\u003e [M, L, Included, ...] M.singleton_class.ancestors # =\u003e [#\u003cClass:M\u003e, #\u003cClass:L\u003e, Extended, ...]   As you can see, while L appears in M's ancestors, Extended does not, and while L's singleton class appears in M's singleton class’s ancestors, Included does not.\nConclusion (or TL; DR) Here’s what I hope you take away from this post:\n Objects are the composition of state and a reference to a class. The “real” class of any object is its singleton class. Class are just normal objects, and their class named Class. prepend and include affect the behaviour offered by the receiver. extend affects the behaviour of the receiver, through its singleton class.  ","description":"A post in which I try to explain Ruby’s Object Model: Objects, Classes, Singleton Classes, Modules…","tags":null,"title":"The Ruby Object Model","uri":"/posts/the-ruby-object-model/"},{"categories":["Ruby"],"content":"For years, Rubyists (including where I work) have enjoyed the privilege of omitting parenthesis around method call arguments. Last week, we merged a pull request to our style guide revoking that privilege: parenthesis will become mandatory for all method calls with arguments.\n Don’t let anyone fool you, Ruby is a complicated language. It’s syntax is full of quirks, pitfalls, and gotchas. It’s a minefield for newcomers and veterans alike. Despite that, it can be an elegant language; we just have to choose which subet of the language to use. We chose that this subset doesn’t allow omitting parentheses on methods which have parameters.\nThe discussion on wheter to enforce parentheses or not was a recurrent one. The arguments in favour of enforcing were generally around predictiblity, or removing the surface for mistakes. The arguments against cited that enforced usage of parentheses is inconsistent with Ruby in the wild, it’s not idiomatic. While arguments against have prevailed until now, the tipping point has been reached this week. Let’s examine what happened.\nThe Final Straw Last week, I stumbled on the following piece of code in a slide deck describing a new feature:\n1 2 3  assert nodes.all? do |node| !node[\"content\"].empty? end   Seasoned Ruby developers may understand the problem with this code, though it is far from self-evident. The issue is that block precedence is different for do/end and {} blocks. As a result, the two following blocks are not identical:\n1 2 3 4 5 6 7  assert nodes.all? do |node| !node[\"content\"].empty? end assert nodes.all? { |node| !node[\"content\"].empty? }   To understand the block precedence differences, we can group the expressions using parentheses to see what the VM will evaluate:\n1 2 3 4 5 6 7  assert(nodes.all?) do |node| !node[\"content\"].empty? end assert(nodes.all? { |node| !node[\"content\"].empty? })   As you can see, they are not at all the same. The first case sends the return value of nodes.all? to assert, along with a block. The assert method does not expect a block, but also doesn’t fail: in Ruby, all methods will implicitly accept a block, regardless of whether they intend to or not.\nWith this in hand, I wanted to know how many other occurrences there were. I redefined assert to raise whenever it was called with a block, in order to know if the issue was a one-off, or systemic. There were 27 occurrences, out of which 7 didn’t pass once corrected. 27 mistakes counting only calls to assert. I haven’t checked further to see if other methods were unintendly called with a block that was meant for another receiver, as it’s pretty much impossible to script.\nThis find was the straw that broke the camel’s back. Something had to be done.\nThis example is (unfortunately) not the only problem with omitting parentheses. So many things can (and will!) go wrong.\nWhat Else Can Go Wrong Beyond inadvertently sending a block to the wrong method, many things can happen to Ruby methods. We’ll explore only the things that involve omitting parentheses. Every method accepting variadic or optional parameters is vulnerable to a slew of hard-to-detect issues. The following sections will show a few of these potential issues.\nDisclaimer: Ruby developers like to omit parentheses moreso on what they call “macros” than on what they consider to be normal methods. In the code examples, “macros” will be over-represented.\nNote about macros: there is no such thing as a language-level macro in Ruby, like you would find in C, Elixir, or Rust. Ruby macros are only social contracts, and have various definitions. Some people define it loosely as the methods that could reasonably be macros in other languages. This would include assert, has_many, extend and include, to name a few. Others would more formally define it as a method call with an implicit receiver where the receiver is a Module. Because I can’t possibly be expected to learn the list of all methods which fall in the first definition, and that the first definition is generally a superset of the second, I personally tend to subscribe to the 2nd definition.\nExtra Trailing Commas Consider the attr_reader method, on which it is generally accepted to not put parentheses. It’s variadic nature means that you can call it with any number of arguments.\n1 2 3 4 5 6 7 8 9  class Foo attr_reader :a, :b, :c def initialize @thing = true end end   The attr_reader method is just a regular method, and unlike in some other languages, it’s arguments can be the result of other expressions.\nUnwittingly removing the last line change will not be a syntax error but may greatly impact the behaviour of the code:\n1 2 3 4 5 6  class Foo attr_reader :a, :b, - :c  def initialize   The subtlety lies in the fact that def initialize will return the :initialize symbol, which will get passed to attr_reader as the 3rd positional argument, effectively making this code attr_reader(:a, :b, :initialize). Suddenly, the Foo class has an initialize attribute reader.\nThis could very well pass code review, because it is so subtle.\nThis extra trailing comma is only a problem because the arguments to attr_reader were not within parentheses; attr_reader(:a, :b,) would not result in the same problem.\nAdd parentheses.\nMissing Trailling Commas Extra trailing commas are not the only offenders; missing trailing commas are also problematic. Imagine a refactorig scenario that leads to this perfectly valid code:\n1 2 3 4 5 6  def can_access?(resource, allowed_users_and_orgs, denied_users = []) # work end can_access? load_blog_post_from_params(params), @users_allowed_on_blog_posts @users_denied_from_blog_posts   The missing trailing comma makes @users_denied_from_blog_posts its own, valid expression which will effectively no-op. It is not sent to the can_access? method. Perhaps this will be caught by your test suite, perhaps it will not.\nAgain, using parentheses would’ve prevented the problem, making the code syntactically invalid.\nAdd parentheses.\nSemantic White Space Whitespace is sometimes semantic in Ruby, and this is generally around method calls, except if preceded by a paren, a comma, a backslash, a colon, and perhaps other punctuation. The simple fact that one has to memorize this rule (and that I don’t know it) is cause for concern.\nThese blocks are equivalent:\n1 2 3 4 5 6 7 8  private(:foo) private( :foo ) private \\ :foo   These are not, although both are perfectly valid Ruby:\n1 2 3 4  private :foo private :foo   Again. Add parentheses.\nLearning Impediment, Cognitive Load When developers are introduced to Ruby (and even more so to Ruby AND Rails), they have to learn a great many things. For reasons I still don’t understand, we teach them that somehow, attr_reader, extend, private, has_many, and so many others have special statuses; they’re not just regular methods. Yet they are. We’re actively hurting their learning experience, for legacy reasons.\nOnce they’ve learned that all methods are the same, they still have to remember and recall an ongoing list of which methods take parentheses, which don’t. This is no easy feat, and adds to the endless stream of decisions one has to make when writing code.\nAs a thought experiment, I was sent this example by a coworker, stating that they could not possibly be expected to add parentheses. The code is copied verbatim:\n1 2 3 4  expect { foo.do_it } .to not_change { foo.total } .and change { bar.count }.by(1) .and change { baz.count }.by(-1)   I must admit I’ve had great difficulty parsing that code. What gets sent to what? What chains on what?\nThe trick with this example is that the indenting is wrong (but copied verbatim). In fact, the first .and chains on the result of not_change {}, not the result of the previous to, as the indenting suggests. The second .and chains on the result of by(1). Writing this code with parentheses even with the wrong indenting makes this clear:\n1 2 3 4  expect { foo.do_it } .to(not_change { foo.total } .and(change { bar.count }.by(1) .and(change { baz.count }.by(-1))))   Yes, add parentheses.\nConsistency and Readability A large number of method calls have much more than one argument. Sometimes, they are long enough to span multiple lines. They are written sometimes adding parentheses, sometimes ommitting them, and some other times using \\.\n1 2 3 4 5 6 7 8 9 10 11 12  attribute \\ :first_name, :last_name has_many :blog_posts, -\u003e { order(id: :asc) }, autosave: false, inverse_of: :author, dependent: :destroy has_many( :subscriptions, class_name: \"Blog::Subscription\", foreign_key: \"author_token\", )   Some may consider that has_many(:posts) or attr_reader(:name) is off-putting, while others may not; it is a subjective matter. I think we can objectively agree that the above code is inconsistent. If for nothing else, our style guide should keep our code consistent.\nJust add parentheses.\nEditors Today’s editors are pretty smart regarding parentheses. They can highlight matching sets of parens, select the internals, navigate to the end. This is all manual labour of parsing code that can be delegate to our tooling.\nThe Decision Now that we understand many of the issues, we can devise ways to avoid them. We’ve found two ways:\n Add a set of new rules to our style guide that prevent all these cases Enforce parentheses everywhere  On the surface, option 1 may seem feasible. After all, if we understand all the problems, surely we can add enough rules to cover all of them. Maybe that’s true, maybe someone can write these rules, and be diligent enough such that none will conflict. That, however, serves to increase the cognitive load.\nOption 2 is a simple rule. One rule. Occam’s Razor suggests it’s the best approach.\nWe believe that the benefits of enforcing parentheses significantly outweigh it’s downsides. Besides, it simplifies the way we write our software, even if just a little.\nWe went from a complicated, noninclusive decision tree,\nTo a much simpler, more inclusive decision tree.\nFinal Considerations: About Idiomatic Code In general, I believe following the community guidelines is preferrable. In light of all the evidence provided, I cannot hold that belief; I have to believe that writing safer and better software is more important than following the style used by others.\nIdiomatic Ruby once was the Seattle Style. I don’t see anyone arguing we should go back. The idiomatic style is just the style which is in vogue at the moment. And it changes, all the time, as new informations, new ideas, new authors come to light. We can be the forbearers of this new, idiomatic style.\n","description":"Not using parentheses on method calls (in Ruby) is unsafe and unpredictable. Use parentheses.","tags":null,"title":"Revoking the (Parentheses) Privilege","uri":"/posts/revoking-the-parentheses-privilege/"},{"categories":["Ruby"],"content":"This is a copy/paste of a comment I made on an internal pull request. I had been tagged on it because on my hard stance against ActiveSupport::Concern, asking me to clarify my objections. I’ve reworded my reply where it made sense.\nHere is the code on which I was asked to comment:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  module Component module AcquiredInformation extend ActiveSupport::Concern included do class \u003c\u003c self class_attribute :component method = method(:component) self.component = Component::Discovery.from_method(method) || Component::Discovery.fallback_component end end module ClassMethods def inherited(klass) klass.component = Component::Discovery.from_caller(caller) || Component::Discovery.fallback_component super end end end end   My Reply My main problem is that ActiveSupport::Concern (later AS::C) encourages bad object-oriented design, while simultaneously having programmers forfeit their understanding of the object model.\nI don’t want to dwell on what Ruby’s object model is; it’s the topic of an other discussion and most of you already know it. One thing is important to understand is that for class MyClass, the instance returned by MyClass.new and the class MyClass itself both are proper objects (later denoted instance and class, respectively). Great care must be applied in designing both, and both must not be confused for the other.\nOO Design AS::C conflates the class and the instance design by encouraging a single module that acts upon both.\nIn all cases where instances are used, the class itself is a factory. Adding more functionality to the class must take that fact into account to not violate the SRP.\nFurthermore, for those that don’t know me, here’s one thing you must know: I fundamentally believe that naming things correctly is a prerequisite for good design. Naming concepts and objects is the best way we have to communicate meaning to one another, it’s basically one of the greatest decomposition technique at our disposal.\nAS::C robs us of this ability to name the things by imposing a ClassMethods name to add features to the class object. The ClassMethods suggests that the module is just a bag of methods without necessitating a common, named concept.\nConsider the CarrierService class (ed: an internal class), which, let’s remind ourself, is a factory generating CarrierService instances. It apparently has many other roles, of which most aren’t properly named.\n\u003e CarrierService.singleton_class.ancestors [ IdentityCache::ShouldUseCache::ClassMethods, IdentityCache::QueryAPI::ClassMethods, IdentityCache::ConfigurationDSL::ClassMethods, IdentityCache::CacheKeyGeneration::ClassMethods, IdentityCache::BelongsToCaching::ClassMethods, EncryptableAttributes::ClassMethods, ... What does it mean to say that CarrierService is a IdentityCache::ShouldUseCache::ClassMethods? Is it a grab-bag of methods related to IdentityCache, or is it a behaviour compatible with the factory role?\nObject Model AS::C has programmers forfeit their understanding of what it means for an object to either include or extend a module, by having them always include, and use the self module to act upon the instance’s class, and ClassMethods module to act upon the class’s class, even in cases where only the latter is necessary.\nTaking the code-at-hand as an example. The only behaviour we want to change it the class’s; the instance should remain unmodified. To do so, the code using AS::C does many things:\n Define a Component::AcquiredInformation module and makes it inherit from AS::C Defines a ClassMethod module Upon defining instances as inheriting from Component::AcquiredInformation, it reopens that instances’s class to define an attribute on it Upon defining a class that inherits from Component::AcquiredInformation::ClassMethods, it modifies the class to overwrite the attribute  Now consider a module built for the same purpose but that doesn’t conflate instance and class. It could use the extended hook to define the attribute, and the inherited hook to overwrite the attribute.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  module Component module AcquiredInformation def self.extended(base) base.class_attribute :component method = base.method(:component) base.component = Component::Discovery.from_method(method) || Component::Discovery.fallback_component end def inherited(klass) klass.component = Component::Discovery.from_caller(caller) || Component::Discovery.fallback_component super end end end   I agree that this still isn’t the greatest OO design, but at least it’s radically simpler.\nBecause I struggle to find a single case in which using AS::C actually provides a better design than not using it, I am a hardliner of never using it.\nComment or React\n","description":"Most usages of ActiveSupport::Concern are unnecessary. Here’s why.","tags":null,"title":"Short Rant about ActiveSupport::Concern","uri":"/posts/short-rant-about-activesupport-concern/"},{"categories":["General"],"content":"Disclaimer: I am not a security expert, nor a systems expert. The following text is tinted by my understanding and experience, and probably contains mistakes or misunderstandings.\nEarlier this year, I accidentally uncovered a flaw in GitHub, Heroku and many other similar providers. The flaw essentially allows a denial of service to some users with little effort from the attacker. The situation has not been fixed, and it likely will not be. At the center of the problem is the fundamental mistake of thinking that authentication can be a substitute for identification.\nIdentification is a process through which one claims an identity. One person may have several identities. For example, GitHub knows me under the identity of gmalette. My gamer tag on Steam is Wako. Anyone can claim those identities; anyone can try to login on GitHub using gmalette or on Steam using Wako. We need a way to verify the authenticity of that identity claim, a way to make sure the user really is who they pretend to be.\nAuthentication is the process through which one verifies a claimed identity. Typically, the person being authenticated will produce a document that assures they own the identity. Such documents can be a passport, a credit card’s CVV code, a password, etc.\nOn the internet, we generally use password authentication. That is, when you connect to a website, you provide your identity (username, email address, etc). The server will find the account matching that identity, and use a password for authentication.\nWhat happens when you mistake authentication for identification? What if somehow, your identity was directly related to the authentication mechanism? You can imagine a website where you only have to enter a password to be logged in. The password will be hashed and salted for security, but the system will keep the first 3 characters to identify the user. When a user logs in using a password, the system will find the user using the first 3 characters, and then authenticate using the full password.\nImagine Alice choses the password “123456” (identified by “123”), Bob chooses the password “password” (identified by “pas”). Bob and Alice can both use the system without any problem. That is, until Alice changes her password to “password123456” (also identified by “pas”). Now when Bob enters “password”, he will be wrongly identified as Alice, but will be unable to authenticate because he does not know the password. Bob will be locked out of his account even if it had previously worked. Such a system couldn’t exist, could it?\nMost Git shells I’ve interacted with use a similar process of identification. More specifically, most Git shells identify the user while negotiating an SSH key, before the authentication happens. During the negotiation process, the client SSH will find all the keys it knows. For each key, it will send the fingerprint of the public key to the server. If the key is known to the server, it will send a challenge and SSH will use the private part of the key to respond to the challenge. The challenge may vary based on a few factors, but it always serves to prove that the user being authenticated owns the private key. One type of proof could be to sign a random piece of data. Signing is an operation that can only be performed using the private key, and easily verified using the public key. If a malicious user sends a known fingerprint but can’t respond to the challenge (because they don’t have the private key), they will not be authenticated and will not have access to the user’s data. But there is another, subtler way this process can be used for nefarious purposes.\nThe thing is, you can (and should) expect public keys to be just that — public. You should behave as if everyone on the internet knows your public keys. In fact, many services expose the public keys of their users. GitHub exposes them on their public API without any need for authentication; here are mine. From a security perspective, that’s understood, and not a problem.\nWhen you sign up to GitHub or Heroku, you will typically add your public key to your account. That allows cloning repos using urls such as “git@github.com/user/project”. For convenience reasons, those services usually allow using more than one public key. Because the identification is based on the public key fingerprint, they will prevent two accounts from having the same public key, which can restrict the attack I’m about to describe, but not by much.\nLet’s revisit the previous example, this time using public keys. Bob signs up for GitHub, and uses a key named “id_rsa”. Bob then signs up to Heroku, using a different key named “id_rsa_heroku”. Since SSH will by default always send the keys in the same order, we’ll pretend the key “id_rsa” is sent first. Let’s examine the SSH debug log when Bob connects to Heroku.\n[1] debug1: Next authentication method: publickey [2] debug1: Offering RSA public key: /Users/bob/.ssh/id_rsa [3] debug1: Authentications that can continue: publickey [4] debug1: Offering RSA public key: /Users/bob/.ssh/id_rsa_heroku [5] debug1: Server accepts key: pkalg ssh-rsa blen 277 [6] debug1: Authentication succeeded (publickey). The following happened:\n [2] — Bob offered his first key (id_rsa) [3] — the server tells Bob it doesn’t know the key; try another one [4] — Bob offers the second key (id_rsa_heroku) [5] — The server knows the key. It’s to Bob’s account. It produces a challenge [6] — authentication happens, and Bob is successfully logged in.  Alice knows all the keys, so she adds “id_rsa” to an empty Heroku account (remember, Bob uses “id_rsa_heroku”). What happens when Bob tries to connect to his Heroku account?\n[1] debug1: Next authentication method: publickey [2] debug1: Offering RSA public key: /Users/bob/.ssh/id_rsa [3] debug1: Server accepts key: pkalg ssh-rsa blen 277 [4] debug1: Authentication succeeded (publickey). The debug log of the SSH connection reads as follows:\n [2] — Bob’s SSH client sends the key “id_rsa” [3] — The server knows this key. It’s to Alice’s account. It produces a challenge [4] — Bob successfully responds to the challenge (he owns the private key) Bob is logged into Alice’s empty account Bob cannot access his own data  This can hardly be classified as an attack, yet Bob is not able to connect to his account. The message Bob will get is: “Your account alice@email.com does not have access to awesome-project”, which will probably leave most users dumbfounded. This denial of service will cause headaches to advanced users, and will seriously ruin the day of less technical people. To be fair, Bob is not completely locked out. SSH allows specifying which key to use when connecting to specific servers.\nA simple solution would be to avoid the single user login git@service.com, and use that as identification, for example gmalette@service.com.\nTo leave you with a simple takeaway, identification and authentication serve a fundamentally different purpose. Thinking they can be interchanged can lead to frustrating issues for users. Please understand what the difference is, and build systems accordingly.\nThanks to Lydia Krupp Hunter and Richard McGain.\nComment or React\n","description":"Earlier this year, I accidentally uncovered a flaw in many providers using git shell, because they mistake Authentication for Identification.","tags":null,"title":"Mistaking Authentication for Identification","uri":"/posts/mistaking-authentication-for-identification/"},{"categories":["Ruby"],"content":"For the past year, my team has been working on a project that exposes a GraphQL API. We’ve been doing things quite differently than the rest of the company, and I think some of our ideas are worth sharing. We’ve been using the graphql-ruby gem, and even though it doesn’t lend itself well to unit testing, we’ve insisted on writing unit tests. What’s more, we’ve also used Sorbet to prevent other categories of errors; in fact, most of our code is using typed: stric! In this post, I’ll share why we went out of our way to do this, and how it can be done.\nIf you don’t like boilerplate code, beware, the quantity of boilerplate required is staggering!\nNote: for the purpose of this post, I will assume that you are familiar with the Sorbet and GraphQL syntaxes.\nPrimer I want to start by explaining some of the challenges we had in designing our GraphQL API. The project we’re working on is an integration point for many other teams and projects of different domains, most of which we don’t control. However, these domains need inputs from the API, and they need to expose data of their own. As a result, my team can’t be expected to know everything going on in the other domains, just as it’s unrealistic to expect other teams to freeze their code.\nImplementations will change. Methods will be added and removed. Classes will be renamed. Refactors will happen. For our project to be successful, we need to give developers (both internal and external to the project) the agency to make changes, and the confidence that the changes they’re making are not compromising the stability of the API.\nAPI Simplistically, the goal of the API is to:\n accept inputs from the client map inputs to domain objects invoke a procedure given the domain objects, and receive a domain object map the returned domain object into an output value return the output value to the client  Our goal was to provide a high level of confidence that each of these steps works as expected, at the lowest cost possible.\nWhy Unit Tests The graphql-ruby section on tests suggests relying on unit testing the domain, and integration testing the API. Integration testing is great, but it isn’t enough to check that domain types map correctly to API types, that API input types map correctly to domain types, or that the correct procedures will be invoked. Our API contains many, many types, and building tests that cover the cardinality of all possible type mapping would make for a very slow test suite. Unit tests don’t suffer from this problem, especially when paired with static analysis.\nUnit tests allow us to check that all tested values will be mapped as expected.\nWhy Static Typing I like to think of values used in APIs as a pyramid, in which the domain must be able to support all input values, and the output must support all the domain values.\nFor example, your API could use these types, where all types are identical:\nInput = Integer Domain = Integer Output = Integer It’s also possible to use an actual pyramid of types:\nInput = Integer Domain = Integer | Float Output = Numeric However, using types that can’t naturally represent the values they must support will require constraining. For example, if you used the following types, the API would require another way to constrain the values, often resorting to errors:\nInput = Float Domain = Integer Output = PositiveInteger In GraphQL and Ruby, constraining is quickly required, because GraphQL’s Int type is limited to 32 bits, whereas Ruby’s Integer type is not.\nIn practice, it will not always apply, but starting with that mindset will help us understand how our types are constrained.\nStatic analysis allows us to verify that each layer can support the values representable by the layers above it. This has been especially useful to catch changes in the domain that can’t be mapped by the API, because the tests don’t necessarily exist. For example, this change:\n1 2 3 4  Input = Integer - Domain = Integer + Domain = Integer | Float  Output = Integer   We haven’t been able to write tests of our API that would catch this change and alert us that Output's type must also be changed. Static analysis catches this easily.\nPractical Example For the rest of this article, we’ll be working on a simple API. Suppose there’s another team that owns the entirety of Messages, and yet you still need to allow interacting with Message objects in your API.\nThe domain is simple enough: you can create new messages using Domain::Message.create with an instantiated Domain::Message, and you will get back a Message object.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  # typed: strict class Domain::Message extend(T::Sig) sig do params(message: Domain::Message) .returns(Domain::Message) end def self.create(message) # omitted end # Messages will be anonymous if from_name == nil sig do params(content: String, from_name: T.nilable(String)) .void end def initialize(content:, from_name:) @content = content @from_name = from_name end sig { returns(String) } attr_reader(:content) sig { returns(T.nilable(String)) } attr_reader(:from_name) end   Since we don’t know anything about Messages, we’ll just expose an API that is a direct translation what’s offered internally. This is what the GraphQL definitions would look like, before we start implementing resolvers.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  # For this example, we'll be using mostly # the `MutationRoot`, but the graphql-ruby # gem requires a valid `QueryRoot`, so we'll # provide it with a dummy one. class Api::QueryRoot \u003c GraphQL::Schema::Object field(:version, Integer, null: false) end class Api::Message \u003c GraphQL::Schema::Object extend(T::Sig) # sigs will be added later field(:content, String, null: false) field(:from_name, String, null: true) end class Api::MessageInput \u003c GraphQL::Schema::InputObject extend(T::Sig) argument(:content, String, required: true) argument(:from_name, String, required: false) end class Api::MutationRoot \u003c GraphQL::Schema::Object extend(T::Sig) field(:message_create, Api::Message, null: false) do |f| f.argument(:message_input, Api::MessageInput, required: true) end end   This will generate the following GraphQL IDL:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  schema{query:QueryRootmutation:MutationRoot}typeMessage{content:String!fromName:String}inputMessageInput{content:String!fromName:String}typeMutationRoot{messageCreate(messageInput:MessageInput!):Message!}typeQueryRoot{version:Int!}  Testing Inputs Input types need to be mapped to domain types, and we would very much like to test that they can be mapped correctly. The graphql-ruby gem allows the definition of a prepare method that does this mapping. Unfortunately, for Sorbet’s benefits, we’ll also need to define the fields as private methods. The upside is that we’ll also benefit from runtime validation in addition to static analysis.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class Api::MessageInput \u003c GraphQL::Schema::InputObject # snip sig { returns(Domain::Message) } def prepare Domain::Message.new( content: content, from_name: from_name, ) end private sig { returns(String) } def content self[:content] end sig { returns(T.nilable(String)) } def from_name self[:from_name] end end   Unfortunately, adding tests to Api::MessageInput#prepare requires a bit of boilerplate to instantiate the objects. We can nonetheless test that all inputs will be mapped correctly.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  RSpec.describe(\"Api::MessageInput\") do describe(\"#prepare\") do it(\"can map to a Domain::Message when all values are present\") do input = Api::MessageInput.new( nil, ruby_kwargs: { content: \"Hello Joe\", from_name: \"Guillaume\", }, context: nil, defaults_used: Set.new, ) message = input.prepare expect(message).to(be_kind_of(Domain::Message)) expect(message.content).to(eq(\"Hello Joe\")) expect(message.from_name).to(eq(\"Guillaume\")) end it(\"can map to a Domain::Message with a nil from_name\") do input = Api::MessageInput.new( nil, ruby_kwargs: { content: \"Hello Joe\", from_name: nil, }, context: nil, defaults_used: Set.new, ) message = input.prepare expect(message).to(be_kind_of(Domain::Message)) expect(message.content).to(eq(\"Hello Joe\")) expect(message.from_name).to(be_nil) end end end   Running tests show that this works as expected.\n$ rspec Api::MessageInput #prepare can map to a Domain::Message when all values are present can map to a Domain::Message with a nil from_name 2 examples, 0 failures Testing Return Values Testing return values will require a lot more boilerplate than for inputs.\nThe graphql-ruby gem instantiates GraphQL::Schema::Object values for every object passing through it, which has the benefit of being convenient if you’re abiding to all its recommendations, but wasteful if you aren’t. Instead, we’d rather define functions that map from the domain objects into API objects, making them easier to test. To do that, we’ll delegate one method per field to a singleton object. In our project we chose to have a Resolvers module per GraphQL class, with one singleton method per field.\nPure delegation isn’t going to work either, as we need to pass the underlying domain object. Luckily, Ruby has refinements which allow adding a smart delegate method that will not be exposed externally.\nNote: In our project we’ve also found that we needed to pass the context in some situations. context will not be needed in this example, but I’m going to include it nonetheless. Our implementation is much longer and contains many verifications to remove affordances: the field must exist, the method must exist on the delegate, its arity must be correct, etc. I can provide a more thorough implementation if there’s interest.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  # typed: false # Unfortunately, Sorbet doesn't understand # refinements for the moment, so this file # has to be untyped. You'll also need to # define a shim for `GraphQL::Schema::Object`, # defining `delegate_to`. module Api::GraphQLDelegation refine(GraphQL::Schema::Object.singleton_class) do def delegate_to(delegate, methods:) methods.each do |method_name| delegate_method = delegate.method(method_name) define_method(method_name) do |**args| if args.empty? delegate_method.call(object, context) else delegate_method.call(object, context, **args) end end end end end end   Our implementation of the Resolvers module defines a lot of boilerplate, and I wish this was available in the graphql-ruby gem: it could forego instantiating objects and strictly use delegates.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  class Api::Message \u003c GraphQL::Schema::Object using(Api::GraphQLDelegation) # fields omitted # The Resolvers module defines one strongly # typed functions for all `fields`. module Resolvers class \u003c\u003c self extend(T::Sig) sig do params(object: Domain::Message, _: BasicObject) .returns(String) end def content(object, _) object.content end sig do params(object: Domain::Message, _: BasicObject) .returns(T.nilable(String)) end def from_name(object, _) object.from_name end end end delegate_to(Resolvers, methods: [:content, :from_name]) end   This makes it easy to test that the Resolvers module can map from a domain type to types that GraphQL can represent.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  RSpec.describe(\"Api::Message\") do describe(\"#from_name\") do it(\"returns the message author's name\") do message = Domain::Message.new( content: \"Hello Joe\", from_name: \"Guillaume\", ) expect(Api::Message::Resolvers.from_name(message)) .to(eq(\"Guillaume\")) end it(\"can be nil\") do message = Domain::Message.new( content: \"Hello Joe\", from_name: nil, ) expect(Api::Message::Resolvers.from_name(message)) .to(be_nil) end end describe(\"#content\") do it(\"returns the message's content\") do message = Domain::Message.new( content: \"Hello Joe\", from_name: \"Guillaume\", ) expect(Api::Message::Resolvers.content(message)) .to(eq(\"Hello Joe\")) end end end   And run it!\n$ rspec Api::MessageInput #prepare can map to a Domain::Message when all values are present can map to a Domain::Message with a nil from_name Api::Message #from_name returns the message author's name can be nil #content returns the message's content Finished in 0.00612 seconds (files took 0.33929 seconds to load) 5 examples, 0 failures While we don’t necessarily need to test the actual Api::Message object (since it performs no work), we chose to have another separate test that makes sure all boilerplate and wiring is done correctly. This test will be out of the scope of this post, however.\nWe will also implement and test the MutationRoot in the same way. There are two differences here, however. First, the object delegated by the MutationRoot has no semantic value, so we’ll just treat it as a BasicObject. Second, the graphql-ruby gem passes the field arguments as named parameters, so we’ll need to define them explicitly, and also define _context explicitly.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class Api::MutationRoot \u003c GraphQL::Schema::Object using(Api::GraphQLDelegation) # fields omitted module Resolvers class \u003c\u003c self extend(T::Sig) sig do params( _obj: BasicObject, _context: BasicObject, message_input: Domain::Message, ).returns(Domain::Message) end def message_create(_obj, _context, message_input:) Domain::Message.create(message_input) end end end delegate_to(Resolvers, methods: [:message_create]) end   We can also write unit tests for the MutationRoot.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  RSpec.describe(\"Api::MutationRoot\") do describe(\"#message_create\") do it(\"calls Domain::Message with the message\") do message = Domain::Message.new( content: \"Hello Joe\", from_name: \"Guillaume\", ) expect(Domain::Message) .to(receive(:create).with(message).and_return(message)) Api::MutationRoot::Resolvers .message_create(nil, nil, message_input: message) end end end   Note: If you’d rather not use expect, you can use the context object to allow dependency injection. We do this extensively and it works well.\n$ rspec Api::MutationRoot #message_create calls Domain::Message with the message Finished in 0.0111 seconds (files took 0.34917 seconds to load) 1 examples, 0 failures While we’re at it, let’s see what Sorbet has to say.\n$ srb tc No errors! Great job. Sweet! However, this isn’t very surprising, since we haven’t told Sorbet about the links between the API classes. For example, it would be possible for Api::MessageInput#prepare to return a value that’s incompatible with message_create.\n1 2 3 4 5 6 7 8 9 10 11 12 13  class Api::MessageInput \u003c GraphQL::Schema::InputObject # snip - sig { returns(Domain::Message) } + sig { returns(Integer)) }  def prepare - Domain::Message.new( - content: content, - from_name: from_name, - ) + 1  end end   Sorbet isn’t able to tell us that this produces an invalid value.\n$ srb tc No errors! Great job. Luckily, our test suite would catch this error, but it would be even better if Sorbet could tell us. Let’s do just that.\nAdding Types The problem we currently have is that Sorbet doesn’t understand the coupling required between the different pieces of the domain and API. Adding those will require even more boilerplate, but it’s achievable, and, in my opinion, definitely worth it.\nHere’s how we managed to do it:\n For input types, we define a PrepareType type alias, which is the return type of the prepare method. GraphQL types define an ObjectType type alias, which is the type of the object value they receive. All inputs and outputs can be either PrepareType or ObjectType, or primitive types which GraphQL understands.  On Api::MessageInput, we will define a PrepareType type alias, and use it (rule #1).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Api::MessageInput \u003c GraphQL::Schema::InputObject # snip + PrepareType = T.type_alias { Domain::Message }  - sig { returns(Domain::Message) } + sig { returns(PrepareType) }  def prepare Domain::Message.new( content: content, from_name: from_name, ) end end   On Api::Message, define an ObjectType and use it (rule #2).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  class Api::Message \u003c GraphQL::Schema::Object using(Api::GraphQLDelegation) # fields omitted + ObjectType = T.type_alias { Domain::Message }  module Resolvers class \u003c\u003c self extend(T::Sig) sig do - params(object: Domain::Message, _: BasicObject) + params(object: ObjectType, _: BasicObject)  .returns(String) end def content(object, *_) object.content end sig do - params(object: Domain::Message, _: BasicObject) + params(object: ObjectType, _: BasicObject)  .returns(T.nilable(String)) end def from_name(object, *_) object.from_name end end end delegate_to(Resolvers, methods: [:content, :from_name]) end   Finally, on Api::MutationRoot, we’ll use the type aliases (rule #3).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class Api::MutationRoot \u003c GraphQL::Schema::Object using(Api::GraphQLDelegation) # fields omitted module Resolvers class \u003c\u003c self extend(T::Sig) sig do params( _obj: BasicObject, _context: BasicObject, - message_input: Domain::Message, + message_input: Api::MessageInput::PrepareType, - ).returns(Domain::Message) + ).returns(Api::Message::ObjectType)  end def message_create(_obj, _context, message_input:) Domain::Message.create(message_input) end end end delegate_to(Resolvers, methods: [:message_create]) end   With those changes, our types are properly coupled together, and applying the same erroneous changes as before (prepare returning Integer) will produce errors:\n$ srb tc sorbet.rb:236: Expected Domain::Message but found Integer for argument message https://srb.help/7002 236 | Domain::Message.create(message_input) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ sorbet.rb:16: Method Domain::Message.create has specified message as Domain::Message 16 | params(message: Domain::Message) ^^^^^^^ Got Integer originating from: sorbet.rb:235: 235 | def message_create(_obj, _context, message_input:) ^^^^^^^^^^^^^^ Errors: 1 Success!\nNow let’s be real for a second. Our tests had also caught this problem, and the code required for static analysis added a TON of boilerplate, and you may be wondering: is it really worth it? If you’re used to having static typing or swear by unit testing, you may have already answered “yes”, but it’s entirely normal to remain skeptical. In the next section, we’ll see why I consider all this boilerplate worthwhile, and which situations make it useful.\nChanging Things Recall that the Domain::Message is owned by another team. They will not necessarily tell you when they make changes, in part because they may not know that you’re using their APIs. The boilerplate written in the previous section was an attempt to force them into knowing by coupling our API to theirs.\nWhen we design software, we try to avoid breaking changes, but from what I’ve seen, they’re almost inevitable.\nIn this section, we’ll see how 3 types of breaking changes can be caught by Sorbet that would not have been caught by tests\nInput Narrowing In some cases, it may make sense to narrow the inputs of a method. For example, maybe anonymous messages have been removed from the scope, and the team wants to narrow the input type of fromName to just String.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Domain::Message extend(T::Sig) # snip sig do - params(content: String, from_name: T.nilable(String)) + params(content: String, from_name: String)  .void end def initialize(content:, from_name:) @content = content @from_name = from_name end # snip - sig { returns(T.nilable(String)) } + sig { returns(String) }  attr_reader(:from_name) end   It’s entirely possible that, writing integration tests only, you wouldn’t have written a test for fromName = nil. Luckily, we wrote unit tests, so this change wouldn’t go unnoticed, and it would signal to the domain team that they need to communicate with your team about these changes.\n$ rspec Api::MessageInput #prepare can map to a Domain::Message when all values are present can map to a Domain::Message with a nil from_name (FAILED - 1) Api::Message #from_name returns the message author's name can be nil (FAILED - 2) #content returns the message's content Api::MutationRoot #message_create calls Domain::Message with the message Finished in 0.01886 seconds (files took 0.33419 seconds to load) 6 examples, 2 failures Even in the event that we had omitted to write any test, Sorbet would still catch the problem.\nsorbet.rb:92: Expected String but found T.nilable(String) for argument from_name https://srb.help/7002 92 | content: content, 93 | from_name: from_name, sorbet.rb:25: Method Domain::Message#initialize has specified from_name as String 25 | params(content: String, from_name: String) ^^^^^^^^^ Got T.nilable(String) originating from: sorbet.rb:92: 92 | content: content, 93 | from_name: from_name, Errors: 1 Output Widening Sometimes, the type of the return value will need to be widened, to accomodate for changes. It’s next to impossible to design tests that will preempt errors stemming from this kind of changes, but static analysis will find them without a problem.\nFor example, imagine that, in certain scenarios, Domain::Message.create will not be able to return a Domain::Message. This could happen if the datastore is overwhelmed, for example. The domain team choses to instead buffer the write, and return a Domain::Pending value, indicating that the write will happen at a later time.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  class Domain::Message extend(T::Sig) + class Pending; end + + # Buffer will be a class variable + # just so we can make a working example + @buffer = T.let([], T::Array[Domain::Message]) +  sig do params(message: Domain::Message) - .returns(Domain::Message) + .returns(T.any(Domain::Message, Pending))  end def self.create(message) - # omitted - message + if overwhelmed? + @buffer.push(message) + Pending.new + else + # omitted + message + end  end + sig { returns(T::Boolean) } + def self.overwhelmed? + false + end  # snip end   Once again, Sorbet will find the problem and tell us that the return value of Domain::Message.create is incompatible with Api::MutationRoot#message_create.\n$ srb tc sorbet.rb:143: Returning value that does not conform to method result type https://srb.help/7005 143 | Domain::Message.create(message_input) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Expected Domain::Message sorbet.rb:142: Method message_create has return type Domain::Message 142 | def message_create(_obj, _context, message_input:) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Got T.any(Domain::Message, Domain::Message::Pending) originating from: sorbet.rb:143: 143 | Domain::Message.create(message_input) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Errors: 1 How to handle this kind of change will ultimately be the author’s decision, but I wanted to briefly touch on union type in graphql-ruby and how to handle them in Sorbet.\nIf we wanted to expose the Pending message creation in the GraphQL API, we would introduce a Api::MessagePending type to represent it.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class Api::MessagePending \u003c GraphQL::Schema::Object using(Api::GraphQLDelegation) field(:_singleton_value, :bool, null: false) ObjectType = T.type_alias { Domain::Pending } module Resolvers class \u003c\u003c self extend(T::Sig) sig do params(object: ObjectType, _: BasicObject) .returns(T::Boolean) end def _singleton_value(object, *_) true end end end delegate_to(Resolvers, methods: [:_singleton_value]) end   We would also need to change the return value of messageCreate to be a union of Pending and Message, which we can call MessageCreateResult. Luckily, the union types in graphql-ruby make it easy to add Sorbet, so we won’t need to rely on the Resolvers module like before. We just need to make sure that its ObjectType is the union of all ObjectType of its possible_values. In the resolve_type method, we can even make use of Sorbet’s exhaustiveness checking (T.absurd).\nOur resolve_type will return a tuple of two values, which allows returning the GraphQL class that contains the mapping functions, as well as unwrapping the value. This isn’t super useful in the current code, but if you were using wrapper objects (like a Result type), it would simplify the code a lot, since members of the union wouldn’t need to share one type.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class Api::MessageCreateResult \u003c GraphQL::Schema::Union extend(T::Sig) possible_types(Api::Message, Api::MessagePending) ObjectType = T.type_alias do T.any(Api::Message::ObjectType, Api::MessagePending::ObjectType) end sig do params(object: ObjectType, _: BasicObject) .returns(T.any( [T.class_of(Api::Message), Api::Message::ObjectType], [T.class_of(Api::MessagePending), Api::MessagePending::ObjectType], )) end def self.resolve_type(object, *_) case object when Domain::Message [Api::Message, object] when Domain::Message::Pending [Api::MessagePending, object] else T.absurd(object) end end end   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class Api::MutationRoot \u003c GraphQL::Schema::Object using(Api::GraphQLDelegation) # fields omitted module Resolvers class \u003c\u003c self extend(T::Sig) sig do params( _obj: BasicObject, _context: BasicObject, - ).returns(Api::Message::ObjectType) + ).returns(Api::MessageCreateResult::ObjectType)  end def message_create(_obj, _context, message_input:) Domain::Message.create(message_input) end end end delegate_to(Resolvers, methods: [:message_create]) end   Conclusion In this post, we’ve seen a few ways in which we can define GraphQL schemas in Ruby, unit test them, and add Sorbet static analysis. We’ve seen a few ways in which unit tests and Sorbet would be able to catch breaking changes, which would be next to impossible to catch using integration tests only.\nI hope that you’ll now consider annotating your GraphQL schema with Sorbet and benefit from its much faster feedback loop, as well as its ability to reveal bugs that are impossible to find only with tests.\n","description":"","tags":null,"title":"GraphQL ❤️ Sorbet and Unit Tests","uri":"/posts/graphql-and-sorbet-and-unit-tests/"}]
